# Verification Data Model (Static Open Badges)

## Architecture Overview
This model enables fully static, privacy-preserving badge verification using GitHub Pages. The Issuer (GitHub Action) serves signed JSON assertions where the recipient's identity is obscured via salted hashing. Verification occurs client-side in the viewer's browser.

## 1. Data Schema (The Assertion)
Reference: Open Badges v3.0

### Public Fields (Hosted JSON)
Located at: `https://[org].github.io/wsg-mooc/assertions/[uuid].json`

```json
{
  "@context": "https://w3id.org/openbadges/v3",
  "id": "urn:uuid:550e8400-e29b-41d4-a716-446655440000",
  "type": "Assertion",
  "recipient": {
    "type": "email",
    "hashed": true,
    "salt": "a1b2c3d4e5f6g7h8", 
    "identity": "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
  },
  "badge": {
    "id": "https://[org].github.io/wsg-mooc/badges/fed-01.json",
    "type": "BadgeClass",
    "name": "Sustainable Web Implementation: Front-end",
    "description": "Validation of front-end sustainability curriculum completion."
  },
  "verification": {
    "type": "HostedBadge"
  },
  "issuedOn": "2026-01-14T12:00:00Z",
  "evidence": [
    {
      "type": "VerificationObject",
      "description": "Cryptographic hash of the learner's local Evidence Pack (evidence.json).",
      "digest": "sha256-88d4266fd4e6338d13b845fcf289579d209c897823b9217da3e161936f031589"
    }
  ]
}
```

### Private Fields (Never Persisted on Server)
These fields exist only in the GitHub Action runtime (ephemeral) or the User's browser.
*   **Raw Email**: Used once to generate the hash, then discarded.
*   **Evidence Content**: The actual text of reflections and audit scores remains in the user's `localStorage` (`evidence.json`). Only the hash is public.

## 2. Hashing Approach (Privacy Protection)

To prevent rainbow table attacks on public badge sets, every badge is individually salted.

**Algorithm:** SHA-256
**Formula:** `hash = SHA256( email.toLowerCase().trim() + salt )`

*   **Salt Generation**: A random 16-character alphanumeric string generated by the GitHub Action during the `issue_badge` workflow.
*   **Storage**: The `salt` is stored cleartext in the JSON (required for verification), but because it is unique per badge, an attacker cannot pre-compute hashes for a list of known emails.

## 3. Verification Page Logic (Client-Side)

The verification page (`/verify/index.html`) contains no backend logic. It fetches the assertion and validates input locally.

### User Flow
1.  User/Verifier visits `https://.../verify?id=[uuid]`.
2.  Page loads the JSON Assertion.
3.  Page displays badge details (Name, Date, Description).
4.  Page shows "Recipient: *Hidden*".
5.  Verifier asks Learner for their email address.
6.  Verifier enters email into "Verify Identity" input.
7.  Browser calculates `AttemptHash = SHA256(InputEmail + JSON.recipient.salt)`.
8.  Browser compares `AttemptHash` === `JSON.recipient.identity`.
    *   **Match**: ✅ "Verified: Issued to [Email]"
    *   **Mismatch**: ❌ "Evidence does not match this email."

### Validation Logic (Pseudocode)

```javascript
async function verifyBadge(userEmail, assertionUrl) {
  // 1. Fetch the public assertion
  const response = await fetch(assertionUrl);
  const assertion = await response.json();
  
  // 2. Extract salt and target hash
  const { salt, identity } = assertion.recipient;
  
  // 3. Hash the input
  const normalizedEmail = userEmail.trim().toLowerCase();
  const msgBuffer = new TextEncoder().encode(normalizedEmail + salt);
  const hashBuffer = await crypto.subtle.digest('SHA-256', msgBuffer);
  const hashArray = Array.from(new Uint8Array(hashBuffer));
  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  
  // 4. Compare
  return (hashHex === identity);
}
```

## 4. Evidence Verification (Optional Audit)

If a third party (employer) wants to verify *what* was learned:
1.  Learner exports `evidence.json` from their browser and sends it to Verifier.
2.  Verifier uses the Verification Page's "Upload Evidence" slot.
3.  Browser calculates `SHA256(evidence.json file content)`.
4.  Browser compares this to `assertion.evidence[0].digest`.
5.  **Match**: Proves that the Reflection Journal provided truly generated this badge.
